### 스프링 + JPA

- 스프링 DI/IoC는 어떻게 동작하나요?
    
    IoC(제어의 역전)은 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것으로 코드의 최종호출은 개발자가 제어하는 것이 아닌 프레임워크 내부에서 결정된 대로 이루어집니다.
    
    DI(의존관계 주입)은 스프링 프레임워크에서 지원하는 IoC 형태로 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결해줍니다.
    
    스프링에서는 스프링 컨테이너 어플리케이션 컨텍스트를 이용해 설정 정보를 생성, 등록하고 필요한 객체를 생성자 혹은 setter를 통해 주입합니다.
    
- 스프링 빈이란 무엇인가요?
    
    IoC 컨테이너 안에 들어있는 객체로 필요할 때 IoC 컨테이너에서 가져와서 사용합니다. ComponentScan을 이용하거나 @Configuration의 @Bean을 사용하거나 xml설정을 통해 일반 객체를 Bean으로 등록할 수 있습니다.
    
- 스프링 빈의 생성과정을 설명해주세요
    
    객체 생성 →의존 설정 → 초기화 → 사용 → 소멸 과정의 생명주기를 가지고 있습니다. 빈은 스프링 컨테이너에 의해 생명주기를 관리합니다.
    
- 스프링 빈의 스코프에 대해 설명해주세요
    
    빈 스코프는 빈이 존재할 수 있는 범위를 뜻하며 싱글톤, 프로토타입, request, session, application 등이 있습니다. 싱글톤은 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프입니다. 프로토타입은 빈의 생성과 의존관계 주입까지만관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프입니다. request는 웹 요청이 들어오고 나갈때까지 유지하는 스코프, session은 웹 세션이 생성, 종료할때까지, application은 웹 서블릿 컨텍스트와 같은 범위로 유지하는 스코프입니다.
    
- IoC 컨테이너의 역할은 무엇인가요?
    
    어플리케이션 실행시점에 빈 오브젝트를 인스턴스화 하고 DI한 후에 최초로 어플리케이션을 기동할 빈 하나를 제공해줍니다.
    
- DI의 종류는 어떤것이 있고 이들의 차이는 무엇인가요?
    
    DI는 세가지 방법이 있습니다. 생성자 주입, Setter 주입, 필드 주입입니다. 생성자 주입은 생성자 호출시점에 딱 1번만 호출되는 것을 보장하며 불변, 필수 의존관계에 사용합니다. Setter주입은 선택, 변경 가능성이 있는 의존관계에 사용되며 스프링빈을 선택적으로 등록이 가능합니다. 필드 주입은 @Autowired를 사용하는데 외부에서 변경이 불가능하여 테스트하기 힘듭니다. DI 프레임워크 없이는 작동하기 힘들며 주로 어플리케이션과 상관없는 테스트코드나 @Configuration과 같은 스프링 설정 목적으로 사용합니다.
    
- @Autowired를 사용한 Autowiring 과정에 대해 설명해주세요
    
    컨테이너에서 인터페이스 또는 오브젝트를 이용해 의존 대상 객체를 검색하고 할당할 수 있는 빈 객체를 찾아 주입합니다.
    
- 스프링 웹 MVC의 디스패처 서블릿의 동작 원리에 대해서 간단히 설명해주세요
    
    클라이언트의 모든 요청을 한 곳으로 받아서 요청에 알맞는 핸들러, 즉 컨트롤러에게 위임해주는 역할을 수행합니다.
    
    우선 사용자의 요청이 디스패처 서블릿으로 전달되면 디스패처 서블릿은 이를 핸들러 맵핑 또는 컨트롤러에게 전달합니다. 응답은 스프링 웹 MVC가 처리된 결과 값을 모델 형태로 디스패처에 반환하고 디스패처는 이를 뷰에게 전달해 사용자에게 보여주고자 하는 뷰 형태로 뷰 리졸버가 페이지 생성을 할 수 있게끔 합니다. 마지막으로 생성된 페이지값에 모델을 포함시켜서 전달하게 됩니다.
    
- 프론트 컨트롤러 패턴이란 무엇인가요?
    
    클라이언트의 다양한 요청마다 서블릿을 만들어서 사용하면 개발과 유지보수의 효율성이 떨어집니다. 프론트 컨트롤러 패턴을 사용함으로써 각 요청을 적절한 곳으로 위임해주어 성능이 증가하고 모든 요청에 대해 보안, 국제화, 라우팅, 로그와 같은 일반적인 기능을 한 곳에서 캡슐화 할 수 있습니다. 스프링에서는 디스패처 서블릿이 프론트 컨트롤러 패턴을 사용한 예이며, 디스패처 서블릿이 빈으로 등록되어 패키지를 스캔하고 @Controller, @RestController 애너테이션을 확인하여 어떠한 요청이 들어왔을 때 적절한 핸들러 메서드에게 위임해줍니다.
    
- 서블릿 필터와 스프링 인터셉터의 차이는 무엇인가요? X
    
    서블릿 필터는 javax패키지에 포함되어있는 클래스이고 인터셉터는 Spring MVC 스펙에 포함되어있는 클래스입니다. 서블릿 필터는 서블릿에서 전후처리를 담당하며 인터셉터는 스프링에서 핸들러를 실행하기 전후나 뷰리졸버를 통해 컨트롤러에서 리턴한 뷰 이름으로부터 렌더링을 담당할 뷰 오브젝트를 준비해 돌려준 후 실제 뷰를 렌더링한 후의 처리를 담당합니다. 
    
- CORS 에러는 무엇인가요?
    
    cross origin resource sharing을 의마합니다. origin은 Url 주소상에서 프로토콜, 도메인 이름, 포트를 포함한 개념입니다. same origin 이란 같은 origin을 뜻하고 cross origin이란 다른 origin을 뜻하는데 이를 cors의 뜻으로 풀어보면 서로 다른 origin간의 리소스 교환에서 발생하는 에러를 의미합니다.
    
    스프링에서는 서블릿 필터를 사용하여 커스텀한 Cors를 설정하거나 ~(이하 생략. 지금 봐도 모름)
    
- @Bean과 @Component간의 차이점에 대해 설명해주세요
    
    @Bean은 개발자가 작성한 메서드를 기반으로 메서드에서 반환하는 객체를 인스턴스 객체를 싱글톤 스코프의 범위로 생성합니다. @Component는 개발자가 작성한 클래스를 기반으로 실행시점에 인스턴스 객체를 싱글톤 스코프의 범위로 생성합니다. @Controller, @Service, @Repository는 모두 @Component이며 실행시점에 자동으로 의존성을 주입합니다.
    
- pojo란 무엇인가요?
    
    프레임워크 인터페이스, 클래스를 구현하거나 확장하지 않은 단순한 클래스로 자바에서 제공하는 api외에 종속되지 않습니다. 따라서 코드가 간결하고 테스트 자동화에 유리합니다. 스프링에서는 도메인과 비즈니스 로직을 수행하는 대상이 pojo 대상이 될 수 있습니다.
    
- 스프링 웹 mvc에서 요청마다 스레드가 생성되어 컨트롤러를 통해 요청을 수행할 텐데 어덯게 1개의 컨트롤러만 생성될 수 있나요?
    
    컨트롤러는 싱글톤 스코프의 빈으로 등록되기 때문에 가능합니다.
    
- @RequestParam 과 @PathVariable의 차이는 무엇인가요?
    
    @RequestParam은 key = value 형태로 값을 보내어 쿼리 문자열에서 값을 추출하고 @PathVariable은 URI 경로에서 값을 추출합니다. (ref. [https://github.com/f-lab-edu/ec_mall/blob/main/src/main/java/com/example/ec_mall/controller/HomeController.java](https://github.com/f-lab-edu/ec_mall/blob/main/src/main/java/com/example/ec_mall/controller/HomeController.java))
    
- JPA 영속성 컨텍스트의 이점 5가지를 설명해주세요 X
    
    영속성 컨텍스트를 쓰는 이유는 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩이 있습니다.
    
    1차 캐시란 캐시 메모리의 역할을 합니다. 동일성 보장이란 ==을 통해 동일성 비교가 가능한 특징을 말합니다. 쓰기 지연은 트랜잭션을 지원하는 쓰기 지연이 가능하며 트랜잭션 커밋하기 전까지 SQL을 바로 보내지 않고 모아서 보낼 수 있습니다. 변경 감지는 스냅샷으로 1차 캐시에 들어온 데이터를 찍고 커밋되는 시점에 엔티티와 스냅샷을 비교하여 update SQL을 생성합니다. 지연 로딩은 엔티티에서 해당 엔티티를 불러올 때 SQL
    
- JPA 전파 단계를 설명해주세요 X
- JPA 를 왜 쓰시는건가요?
    
    객체지향 프레임워크이기 때문입니다. JPA를 사용하면 비즈니스 로직이 RDBMS에 의존하는 것이 아니라 자바 코드로 표현될 수 있기 때문에 생산성이 높아진다고 볼 수 있습니다.
    
    또한 JPA는 JPQL로 SQL을 추상화하기 때문에 RDBMS의 Vendoer에 관계없이 동일한 쿼리를 작성해서 같은 동작을 기대할 수 있다는 장점도 있습니다. 이는 database dialect를 지원하기 때문에 가지는 장점입니다. 
    
- database dialect란 무엇인가요?
    
    jpa, hibernate등의 플랫폼에 독립적인 소프트웨어의를 위한 configuration setting 입니다.
    
- JPA의 N+1문제는 무엇이고 이것이 발생하는 이유와 해결 방법에 대해 설명해주세요 X
